三层架构
表现层：WEB层，用来和客户端(浏览器)进行数据交互的。表现层一般会采用MVC的设计模型(Servlet、HTML、Spring、SpringMVC)
业务层：处理公司具体的业务逻辑的(Spring)
持久层：用来操作数据库的(JDBC、Mybatis、Spring)

SpringMVC是一种基于Java实现的MVC模型的轻量级Web框架（底层基于Spring，封装了web三大组件Servlet、Filter、Listener）
SpringMVC使用简单，开发便捷，灵活性强
一、SpringMVC架构
- Model（模型）：负责封装应用的状态，并实现应用的功能。通常分为：数据模型、业务逻辑模型
- View（视图）：页面视图，用于展示数据 （因为开发中前后端分离了，这块内容后端技术人员接触少了）
- Controller（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑

二、使用SpringMVC开发的步骤：

1. 导入坐标（SpringMVC依赖、Servlet依赖）
2. 创建SpringMVC控制器类UserController（等同于Servlet）
3. 初始化SpringMVC环境 SpringmvcConfig【没有web.xml文件、没有@WebServlet注解了】
4. 初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC请求拦截的路径,ServletContainerInitConfig

三、使用SPI(Service Provider Interface)机制创建Servlet
SPI是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。
  基于 “接口编程＋策略模式＋配置文件(约定)”组合实现的动态加载机制
1.约定的配置文件必须存放在META-INF/services目录下
2.特定的类加载器
java.util.ServiceLoader类 （类加载器）
ServiceLoader.load(Class cls) //示例：ServiceLoader.load(接口.class)
在ServiceLoader.load的时候，根据传入的接口类，遍历META-INF/services目录下的以该接口命名的文件中的所有类，并实例化返回

ServletContainerInitializer是Servlet3.0新增的一个接口，主要用于在web容器(Tomcat)启动阶段通过编程风格注册Filter、Servlet、Listener，
以取代通过web.xml配置注册。这样就利于开发内聚的web应用框架。

四、SpringMVC执行过程
java工程和web工程的区别：
1.打包方式：Java工程是jar包，web工程是war包
2.运行方式：java工程是直接通过main方法运行，web工程的main方法是在web容器中（web工程必须要部署在web容器上才能运行）

简易版SpringMVC加载机制：

- Tomcat  =>  ServletContainerInitConfig  =>  SpringmvcConfig  =>  UserController
  - Tomcat： web容器
  - ServletContainerInitConfig： web容器配置类（SPI机制）
  - SpringmvcConfig： SpringMVC配置类
  - UserController：表现层的控制器类（等同于Servlet）
- 执行顺序：
  1. Tomcat根据SPI机制加载ServletContainerInitConfig类
  2. ServletContainerInitConfig类中方法执行
  3. SpringmvcConfig类加载（由ServletContainerInitConfig类中方法运行时加载）
  4. UserController类被SpringmvcConfig类扫描到并加载

详解版SpringMVC执行过程分析

SpringMVC加载机制：Tomcat  =>  ServletContainerInitConfig  =>  SpringmvcConfig  =>  UserController

- Tomcat
  - tomcat的main方法执行时，根据SPI机制加载ServletContainerInitConfig类
    1. spring-web.jar下有META-INF/services/javax.servlet.ServletContainerInitializer文件
    2. 此文件中配置实现类 org.springframework.web.SpringServletContainerInitializer
    3. SpringServletContainerInitializer类会被Tomcat所加载(SPI机制)，此类上的有个注解配置，指定要加载的类型
       - @HandlesTypes({WebApplicationInitializer.class})
    4. WebApplicationInitializer接口的所有实现类都会被加载
       - 入门案例中的ServletContainerInitConfig类就是WebApplicationInitializer接口的实现类
- ServletContainerInitConfig（web容器配置类）
  - createServletApplicationContext方法运行，加载springmvc配置类
  - getServletMappings方法运行，给DispatcherServlet类设置访问路径为`/` (表示拦截所有)
- SpringmvcConfig（SpringMVC配置类）
  - @ComponentScan("com.itheima.controller")
    - springmvc底层开始扫描：com.itheima.controller包
- UserController（控制器）[等同于Servlet]
  - @Controller ： 表示此bean会添加到springmvc的ioc容器
  - @RequestMapping("/save") ： 设置访问路径和目标方法的映射
  - @ResponseBody ： 方法的的返回值将会通过响应体返回给前端

五、SpringMVC的请求过程
- 浏览器（前端）
  - 发送请求：`http://localhost:8080/save`
- 服务器（后端）
  1. Tomcat接收到请求
  2. 请求交给DispatcherServlet处理
     - DispatcherServlet设置的请求路径为：`/`（所有请求）
  3. DispatherServlet找到`/save`对应的控制器方法：UserController类中的save()方法
  4. 执行UserController类中的save()方法，并把save()方法执行后的结果，通过响应体返回给前端

六、RequestMapping注解（建立请求路径和目标方法的映射）
RequestMapping所在位置：
1.类上
窄化路径。访问类中的方法时，必须加上类上定义的请求路径
例如：
@Controller
@RequestMapping("/user")
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        return "save success";
    }
}
2.方法
建立请求资源路径与方法的直接对应关系
例如：
@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        return "save success";
    }
}

RequestMapping注解常用属性
- value 或 path：指定访问路径
- method：限定请求方式（restful风格）
  - 不写，默认什么请求方式都可以
  - 指定了请求方式后，如果不匹配就会响应405状态码
例如：
@Controller
@RequestMapping("/user")
public class UserController {
    @RequestMapping(path = "/save",method = RequestMethod.GET)
    @ResponseBody
    public String save(){
        return "save success";
    }

    @RequestMapping(value = "/save",method = RequestMethod.POST)
    @ResponseBody
    public String saveUser(){
        return "save success";
    }
}




